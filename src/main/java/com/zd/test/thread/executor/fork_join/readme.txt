在JDK1.7版本中提供了Fork/Join并行执行任务框架，它的主要作用是把大任务分割成若干个小任务，再对每个小任务得到的结果进行汇总，此种开发方法
也叫分治编程，分治编程可以极大地利用CPU资源，提高任务执行的效率，也是目前与多线程有关的前沿技术。

Fork(分叉)-Join(合并)分治编程与类结构：
    运行流程图如下所示：
                    大任务
                      |
                     fork
           ___________|___________
          |           |           |
        子任务1     子任务2      子任务3
          |           |           |
         fork         |          fork
        __|__         |         __|__
       |     |        |        |     |
 子任务1.1  子任务1.2  |   子任务3.1  子任务3.2
       |_____|        |        |_____|
          |           |           |
         join         |          join
          |           |           |
       任务1结果   任务2结果     任务3结果
          |___________|___________|
                      |
                     join
                      |
                  大任务结果

在JDK中并行执行框架Fork-Join使用了“工作窃取(work-stealing)”算法，它是指某个线程从其他队列里窃取任务来执行，这样做有什么优势或者目的是什么呢？
比如要完成一个比较大的任务，完全可以把这个大的任务分割为若干互不依赖的子任务/小任务，为了更加方便地管理这些任务，于是就把这些子任务分别放到不同
的队列里，这时就会出现有的线程会先把自己队列里的任务快速执行完毕，而其他线程对应的队列里还有任务等待处理，完成任务的线程与其等着，不如去帮助其他线程
分担要执行的任务，于是它就去其他线程的队列里窃取一个任务来执行，这就是所谓“工作窃取(work-stealing)”算法。

在JDK1.7中实现分治编程需要使用ForkJoinPool类，此类的主要作用是创建一个任务池，该类也是继承自AbstractExecutorService类。
类ForkJoinPool所提供的功能是一个任务池，而执行具体任务的却不是ForkJoinPool，而是ForkJoinTask类；
类ForkJoinTask是抽象类，不能实例化，所以需要使用该类的3个子类：CountedCompleter,RecursiveAction和RecusiveTask来实现具体功能。
